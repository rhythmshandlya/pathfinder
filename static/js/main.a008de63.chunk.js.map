{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","PathfindingVisualizer/PathFinder.jsx","App.js","index.js"],"names":["Node","props","col","isFinish","isStart","isWall","onMouseClick","row","extraClassName","id","className","onClick","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathFinder","useState","setGrid","mouseIsPressed","createNode","getNewGridWithWallToggled","newGrid","slice","newNode","animateDijkstra","nodesInShortestPathOrder","i","setTimeout","document","getElementById","animateShortestPath","useEffect","currentRow","console","log","getInitialGrid","currentNode","unshift","getNodesInShortestPathOrder","visualizeDijkstra","map","key","j","handleClick","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.a008de63.chunk.js","sourcesContent":["import React from 'react';\n\nimport './Node.css';\n\nconst Node = (props) => {\n  const { col, isFinish, isStart, isWall, onMouseClick, row,} = props;\n  const extraClassName = isFinish ? 'node-finish': ( isStart ? 'node-start': (isWall? 'node-wall': ''));\n\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      className={`node ${extraClassName}`}\n      onClick={ ()=> onMouseClick(row ,col) }\n      ></div>\n  );\n}\n\nexport default Node;\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, {useState ,useEffect} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dijkstra';\n\nimport './PathfindingVisualizer.css';\n\n//Green Node\nconst START_NODE_ROW = 5;\nconst START_NODE_COL = 5;\n\n//Red Node\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 10;\n\n\nconst PathFinder = () => {\n  const [grid, setGrid] = useState([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState(false);\n\n  const getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < 11; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 15; col++) {\n        currentRow.push(createNode(col, row));\n      }\n      grid.push(currentRow);\n    }\n    console.log(grid);\n    return grid;\n  };\n  \n  const createNode = (col, row) => {\n    return {\n      col,\n      row,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n    };\n  };\n  \n  const getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n  \n  \n  useEffect(() => {\n    const grid = getInitialGrid();\n    setGrid(grid);\n  }, []);\n\n  \n  function handleClick(row,col){\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\n    setGrid(newGrid);\n  }\n\n  function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 20 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 20 * i);\n    }\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 100 * i);\n    }\n  }\n\n  function visualizeDijkstra() {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n\n    //Get relevant information\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n\n    //Perform visual animation\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n    return (\n        <>\n          <br /> <br />\n          <button className='btn' onClick={() => visualizeDijkstra()}>\n            Visualize Dijkstra's Algorithm\n          </button>\n          <div className=\"grid\">\n            {grid.map((row, i) => {\n              return (\n                <div key={i}>\n                  {row.map((node, j) => {\n                    const {row, col, isFinish, isStart, isWall} = node;\n                    return (\n                      <Node\n                        key={j}\n                        col={col}\n                        isFinish={isFinish}\n                        isStart={isStart}\n                        isWall={isWall}\n                        mouseIsPressed={mouseIsPressed}\n                        onMouseClick={()=>{handleClick(row,col)}}\n                        row={row}>\n                        </Node>\n                    );\n                  })}\n                </div>\n              );\n            })}\n          </div>\n        </>\n      );\n}\n\nexport default PathFinder;","import React from 'react';\nimport './App.css';\nimport PathFinder from './PathfindingVisualizer/PathFinder';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <PathFinder />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}